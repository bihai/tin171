\documentclass[a4paper,11pt]{article}
\usepackage{fancyhdr}
\setlength{\headheight}{11pt}
\pagestyle{fancyplain}
\usepackage{algpseudocode}
%\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

\lhead{ }
\rhead{}
%\renewcommand{\headrulewidth}{0.0pt}

\lfoot{Group 1: final report}
\cfoot{\thepage}
\rfoot{}

%
%%    homebrew commands -- to save typing
\newcommand\etc{\textsl{etc}}
\newcommand\eg{\textsl{eg.}\ }
\newcommand\etal{\textsl{et al.}}
\newcommand\Quote[1]{\lq\textsl{#1}\rq}
\newcommand\fr[2]{{\textstyle\frac{#1}{#2}}}
\newcommand\miktex{\textsl{MikTeX}}
\newcommand\comp{\textsl{The Companion}}
\newcommand\nss{\textsl{Not so Short}}


\begin{document}
%-----------------------------------------------------------
\title{Final report\\Fun With Chinese Checkers}
\author{Group 1: Emil Falk, Rodolphe Lepigre,\\
        Salvatore Tomaselli, G\"oran Weinholt}
\maketitle
%-----------------------------------------------------------
\begin{abstract}\centering
%%COMMENT (re-use from project proposal and modify if needed)
Chinese Checkers is a board game for up to six players. The fact that
it is a multi-player game makes it quite different from more widely
explored two-player games like Chess. In writing a computer player for
Chinese Checkers we have explored search algorithms and heuristics.
Our aim is to highlight the ways in which multi-player games differ
from two-player games, and the consequences this has for the
effectiveness of a computer player.
\end{abstract}

\section{Introduction and Background}
% (A short general text about the area of ai that your project belongs to.)
Chinese Checkers is a board game that can be played by two to six players.
Each player controls ten pegs that are placed in the corners of a
hexagonal star. The board has little holes in it where the pegs can be
placed. In each round of the game a player must move a peg in one of
two ways. A peg can be moved to one of the six holes next to it or, if
one of the holes is occupied by another peg, it can also ``jump'' over
that peg in a straight line (thereby traveling two holes over). The
player can jump over other pegs an unlimited number of times every
round, potentially moving a peg straight across the whole board. The
objective is to move all pegs to the opposite corner.
% Maybe it would be nice to add a few lines about the history of the game ?

\subsection{The problem you tried to solve}
% (Re-use from project proposal, add changes, refinements,
% extensions. If there has been major changes since the project
% proposal, describe and motivate.)
We have implemented a computer program capable of playing Chinese
Checkers. Our goal has been to create a program that could beat a
novice human player.

\subsection{Related work}
% (Re-use form project proposal, extend with furhter findings from
% literature study, cite and add references. Expain which are relevant
% for your project and which not and why.)
Sturtevant has explored the max$^n$ and paranoid algorithms in
relation to Chinese Checkers
\cite{springerlink:10.1007/978-3-540-40031-8_8}. The max$^n$ algorithm
is a generalisation of minimax to $n$-player games. The paranoid
algorithm uses the idea that all other players have formed a coalition
(which means there are only really two players). Later on he also
evaluated the UCT algorithm
\cite{springerlink:10.1007/978-3-540-87608-3_4}, which is described as
``Monte-Carlo-like'' and quite effective against max$^n$, but
requiring a lot of computation time.

An interesting point that Sturtevant makes is that multi-player games
(i.e.~Chinese Checkers) are difficult for computers for two reasons:
search strategies are less effective than for two-player games and
there is a need for opponent modelling which is normally not required.

Huang describes a contest in which he supervised students who wrote
programs to play Chinese Checkers \cite{Huang:2001:SGP:378593.378708}.
The students used iter\-ative-deep\-ening search and experimented with
heuristics. We believe that this will be a good way of starting our
project.

Hashavit and Markovitch evaluated the Max-Prob algorithm
\cite{Hashavit}. The algorithm is similar to max$^n$ and paranoid, but
in Chinese Checkers it is significantly better. It computes at each
step which move will be most likely to lead to a winning outcome. It
does this for all players and maximizes its own probability of
winning.

Ulfhake reports on a program for two-player Chinese Checkers
\cite{ulfhake}. The program has a variety of search algorithms
available, including different variants of alphabeta and minimax
search. Something particularly interesting to us is her description of
the heuristics she used. The program was reported to play excellently
against human players.

%% Research into programs that play games is likely to be geared towards
%% producing strong programs that one day will be able to beat the best
%% human players. Perhaps a weaker program would be just as suitable for
%% our needs.

\subsection{Tools and programs available}
% (Re-use and extend your list of tools and programs from the project
% proposal including references. 
% Which ones are you actually using?  Cite and annotate them.  
% Did you encounter any practical difficulties?)
\emph{cheech} is a free software implementation of Chinese Checkers.
It provides a graphical interface and a network protocol. It initially
appeared to us that we could make our own program connect to
\emph{cheech} as a player and thereby use the existing multi-player
functionality and graphics. Unfortunately the program has suffered
significant bit rot and we were unable to compile it. We evaluated
half a dozen alternatives and found that none of them still work
properly. That being said, we did copy the server-client model of
\emph{cheech} for our own work.

\section{The central idea in your solution}
% (Re-use the content and structure of subsections from project
% proposal. Add refinments and extensions, motivate changes compared
% to earlier stages of the project.)
\subsection{Significance}

An interesting aspect of Chinese Checkers is that it is a multi-player
game. This means that players can form temporary coalitions against
other players. While traditional two-player strategies can be used to
play the game they are not going to be able to play it perfectly and
in this sense Chinese Checkers is still an open problem. Working on an
open problem is always interesting.

The multi-player attribute provides a good setting for objectively
evaluating the performance of different algorithms and heuristics. The
existing literature is somewhat sparse on how existing computer
programs fare against humans in multi-player Chinese Checkers. We hope
to rectify that with this report.

\subsection{The central idea in our solution}

The architecture of our solution consists of three parts: a game
server written in Erlang, a graphical game client written in Python
and several autonomous game clients. A network protocol has been
specified that supports multiple running games. The server coordinates
the game and tells each player what is happening to the board and
prompts players to make their move. The server verifies that the moves
are legal and checks if there is a winner. The graphical client can
connect either as a player or a spectator. It shows a graphical
representation of the board and lets the user make moves.

%% Initially our program will be playing a two-player variant of Chinese
%% Checkers. When it is working properly we will try with more players.
%% We will be using an iterative development model that emphasizes
%% getting the basics up and running quickly.

Our first computer player is an implementation of \emph{iterative
  deepening depth-first-search} (IDDFS) \cite{aimodern}. This has been
combined with heuristics to form a kind of informed search. We
currently have two heuristics based on distance functions. The first
is the sum of the Euclidean distance of all pegs from the goal. The
second is a hand-tuned function that tries to penalize the bot when it
is leaving pegs behind and attempts to keep pegs in the middle of the
board, where it is more likely that good paths towards the goal will
be formed. The heuristics described in \cite{ulfhake} will be very
useful for our continued work.

\subsubsection{The Python client}
To be able to test different approaches, the Python client supports multiple
functions.
In general, Python is a slow interpreted language, but there are projects that
aim in providing just in time compilation. The PyPy interpreter has proven to be
somewhat faster than the standard CPython, when forced to compile loops after
few iterations the IDDFS algorithm is able to compute one level deeper.
%% To improve
%% the depth of our solution we will try and do some pruning of ``bad''
%% plys, e.g.~those that do not move the player any closer to the goal
%% state.

The literature describes algorithms that are more capable than
\emph{IDDFS}. An iterative development model means that we will be
making continual improvements to our program, and it is likely that we
will attempt to use some of the more capable algorithms later on. Our
first programs can be preserved for later programs to play against.

%% \subsubsection{Why do you think it will work?}% Not in the report template

%% Our solution will work because we think that \emph{IDDFS} closely
%% relates to how a human might play the game: first evaluating moves
%% that are easily visible on the board and iteratively looking deeper
%% (further) into what might happen.

%% Even though \cite{Huang:2001:SGP:378593.378708} does not report on the
%% performance of \emph{IDDFS} we know that it at least has been used to
%% some degree of success. The performance of our solution will of course
%% depend heavily on finding good heuristics. The first program might not
%% win any contests but it will be able to play the game, because our
%% heuristics can force it to make forward progress.

%% \subsection{Define an instance of the problem. How will you measure the
%%performance of your program?}% Not in the report template
%% %(You must know this in advance, find instances /benchmarks, or make your
%%own).

%% The program should play a game in the same way a human would play: the
%% program waits its turn and makes a move. The initial board setup is
%% one instance of the problem, but from the perspective of analysing the
%% game every intermediate state of the board may also be considered an
%% instance.

%% We want to evaluate the program's performance by having it play
%% against ourselves and other bots.


%% \subsection{The scope of your work}% Not in the report template
%% %(also, what interesting and related things are outside the scope of your
%%proposal?)

%% The scope of our project will ultimately be to try and challenge a set
%% of amateur human players. The first version of the program will play a
%% two-player game and this will later be extended to a multi-player
%% game. In developing the program we will explore how the dynamics of
%% the game changes in the multi-player version. Our program will be able
%% to play against itself, against humans, and against other programs. An
%% evaluation of the different versions of the program will be written.

%% Playing a perfect game must be outside our scope because it appears to
%% be an open research problem.

%% \subsection{Notes on strategies}% not in the report template

%% When we have the basic mechanics of the game and the computer player
%% working there are some strategies that we should consider. Some of the
%% strategies can be implemented by adjusting the heuristic function and
%% some can be implemented \emph{ah hoc}. The following are some ideas
%% for strategies.

%% \textbf{Leave no man behind}. If this strategy is not used it is
%% possible for the computer player to end up with a lot of pegs very far
%% away from the goal. These pegs will be very costly to move toward the
%% goal if it's late in the game, so a heuristic should take that into
%% account.

%% \textbf{Stay the path}. The center of the board is more likely to
%% contain many paths towards the goal. Therefore if the heuristic gives
%% a preference to moves that keep pegs in the middle then the game is
%% likely to move faster and give more opportunities to jump long
%% distances.

%% \textbf{Forge ahead} or \textbf{the best offense is a good defense}.
%% The computer player can either be aggressive and try to create long
%% paths for moving fast and far, or it can be defensive and try to not
%% give any other players opportunities to use its pegs as part of a
%% path.

\section{Overview of the architecture}
% (Describe the different parts of your program suite in detail.)
\subsection{Running modules}
\subsection{Modules designed but not implemented}
\subsection{Modules a future continuation may have}

\section{Results and Evaluation}
% (What does your running code do? How does it fare against your
% benchmarks and instances? Describe advantages and disadvantages,
% possibly in relation to other groups in this course.)

We have a time-limited implementation of iterative-deepening depth
first search based on an algorithm from \cite{aimodern}. When the
algorithm compares two moves that achieve an equally good outcome it
will explicitly favor the move that achieves the outcome sooner (at a
lower search depth). If this check is omitted the algorithm can end up
looping at the end of a game. This is because it would make a move
that would be the winning move two moves into the future, but on the
next turn it might again choose a move that wins two moves into the
future, \emph{ad infinitum}.

\begin{algorithmic}
\Function{IDDFS}{board, player-id, time-limit}
\State best.move = \emph{nil}
\State best.score = $-\infty$
\State best.depth = $\infty$
\For{depth $= 0 \to \infty$}
 \ForAll{move $\in$ possible-moves(board, player-id)}
  \State nboard = update-board(board, move)
  \State RECURSIVE-DLS(move, nboard, depth, 0, best)
 \EndFor
 \If{timeout}
  \State \Return best.move
 \EndIf
\EndFor
\EndFunction
\\
\Function{RECURSIVE-DLS}{move1, board, limit, depth, best}
\State score = board-evaluation(board, player-id)
\If{score $>$ best.score $\vee$ (score $=$ best.score $\wedge$ depth $<$ best.depth)}
\State best.move = move1
\State best.score = score
\State best.depth = depth
\EndIf
\If{limit $\le$ 0 $\vee$ timeout}
\State \Return
\EndIf
\ForAll{move $\in$ possible-moves(board, player-id)}
 \State nboard = update-board(board, move)
 \State RECURSIVE-DLS(move1, nboard, limit$-1$, depth$+1$, best)
\EndFor
\EndFunction
\end{algorithmic}


\section{Discussion and Conclusions}
%(Sum up your project, suggest future extensions and improvements.)

% \section{References}
% (Re-use from previous documents, extend.)
\bibliographystyle{aiaa}
\bibliography{refs}

\section{Appendix}
% (Here you include the diary and all other information and
% documentation that did not fit into the report in the above sections
% but that you consider too important to leave out.)

\end{document}
